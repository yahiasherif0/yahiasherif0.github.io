# Cyfrin passwordStore

# [H-1] Storing password on-chain makes it visible to everyone

### Description:

> All data stored on-chain are visible to anyone, and can be read directly from the blockchain. the `PasswordStore::s_password` is meant to be private variable and only accessed through the `PasswordStore::getPassword()` function, which is intended to be only called by the owner of the contracts.
> 

### Impact

Anyone can read the private password, breaking the functionality of the protocol.

### Proof of Concept

The test case below shows how anyone can read the private password directly from the blockchain.

1. Create a locally running blockchain

```bash
make anvil
```

1. Deploy the contract to the chain

```bash
make deploy
```

1. Get the contract storage data

```bash
cast storage <contract-address> 1
```

> We use 1 because its the storage slot of `s_password` in the contract
> 

You will get the output like this:

`0x6d7950617373776f726400000000000000000000000000000000000000000014`

1. Then you can parse the hex to string using :

```bash
cast parse-bytes32-string 0x6d7950617373776f726400000000000000000000000000000000000000000014
```

output will be 

```bash
myPassword
```

### Mitigation

> Sensitive data such as passwords must never be stored in plaintext on-chain. Since all blockchain storage is publicly accessible, marking a variable as `private` does not make it confidential â€” it only restricts access at the Solidity language level, not at the blockchain level.
> 

# [H-2] `PasswordStore::setPassword` has no access control meaning non owner can change the password

### Description:

> The `PasswordStore::setPassword` function meant to be only accessible by the owner but there is no restrictions implemented on the function meaning any one can call the function and change the password
> 

```solidity
function setPassword(string memory newPassword) external {
        s_password = newPassword;
        emit SetNewPassword();
    }
```

### Impact

Anyone can set/change the password, breaking the contract functionality

### Proof of Concept

Add the following to the `passwordStore.t.sol` test file

```solidity
function testAnyoneCanSetPassword(address randomAddress) public {
string memory expectedPassword = "newpassword";
vm.prank(randomAddress);
passwordstore.setPassword(expectedPassword);
vm.prank(owner);
string memory actualPassword = passwordstore.getPassword();
assertEq(expectedPassword, actualPassword);
}
```

Notice that the test passed confirming that the `passwordStore::setPassword` is callable by any user address

### Mitigation

> Add an access control check that verify that the caller is the owner
> 

```solidity
if (msg.sender != owner){
revert PasswordStore__NotOwner();
}
```
